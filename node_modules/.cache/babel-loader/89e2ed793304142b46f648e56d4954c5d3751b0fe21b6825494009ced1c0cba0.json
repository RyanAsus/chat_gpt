{"ast":null,"code":"\"use strict\";\n\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar _ChatCompletionStream_instances, _ChatCompletionStream_currentChatCompletionSnapshot, _ChatCompletionStream_beginRequest, _ChatCompletionStream_addChunk, _ChatCompletionStream_endRequest, _ChatCompletionStream_accumulateChatCompletion;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ChatCompletionStream = void 0;\nconst error_1 = require(\"openai/error\");\nconst AbstractChatCompletionRunner_1 = require(\"./AbstractChatCompletionRunner.js\");\nconst streaming_1 = require(\"openai/streaming\");\nclass ChatCompletionStream extends AbstractChatCompletionRunner_1.AbstractChatCompletionRunner {\n  constructor() {\n    super(...arguments);\n    _ChatCompletionStream_instances.add(this);\n    _ChatCompletionStream_currentChatCompletionSnapshot.set(this, void 0);\n  }\n  get currentChatCompletionSnapshot() {\n    return __classPrivateFieldGet(this, _ChatCompletionStream_currentChatCompletionSnapshot, \"f\");\n  }\n  /**\n   * Intended for use on the frontend, consuming a stream produced with\n   * `.toReadableStream()` on the backend.\n   *\n   * Note that messages sent to the model do not appear in `.on('message')`\n   * in this context.\n   */\n  static fromReadableStream(stream) {\n    const runner = new ChatCompletionStream();\n    runner._run(() => runner._fromReadableStream(stream));\n    return runner;\n  }\n  static createChatCompletion(completions, params, options) {\n    const runner = new ChatCompletionStream();\n    runner._run(() => runner._runChatCompletion(completions, {\n      ...params,\n      stream: true\n    }, options));\n    return runner;\n  }\n  async _createChatCompletion(completions, params, options) {\n    const signal = options?.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_beginRequest).call(this);\n    const stream = await completions.create({\n      ...params,\n      stream: true\n    }, {\n      ...options,\n      signal: this.controller.signal\n    });\n    this._connected();\n    for await (const chunk of stream) {\n      __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_addChunk).call(this, chunk);\n    }\n    if (stream.controller.signal?.aborted) {\n      throw new error_1.APIUserAbortError();\n    }\n    return this._addChatCompletion(__classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_endRequest).call(this));\n  }\n  async _fromReadableStream(readableStream, options) {\n    const signal = options?.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_beginRequest).call(this);\n    this._connected();\n    const stream = streaming_1.Stream.fromReadableStream(readableStream, this.controller);\n    let chatId;\n    for await (const chunk of stream) {\n      if (chatId && chatId !== chunk.id) {\n        // A new request has been made.\n        this._addChatCompletion(__classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_endRequest).call(this));\n      }\n      __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_addChunk).call(this, chunk);\n      chatId = chunk.id;\n    }\n    if (stream.controller.signal?.aborted) {\n      throw new error_1.APIUserAbortError();\n    }\n    return this._addChatCompletion(__classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_endRequest).call(this));\n  }\n  [(_ChatCompletionStream_currentChatCompletionSnapshot = new WeakMap(), _ChatCompletionStream_instances = new WeakSet(), _ChatCompletionStream_beginRequest = function _ChatCompletionStream_beginRequest() {\n    if (this.ended) return;\n    __classPrivateFieldSet(this, _ChatCompletionStream_currentChatCompletionSnapshot, undefined, \"f\");\n  }, _ChatCompletionStream_addChunk = function _ChatCompletionStream_addChunk(chunk) {\n    if (this.ended) return;\n    const completion = __classPrivateFieldGet(this, _ChatCompletionStream_instances, \"m\", _ChatCompletionStream_accumulateChatCompletion).call(this, chunk);\n    this._emit('chunk', chunk, completion);\n    const delta = chunk.choices[0]?.delta.content;\n    const snapshot = completion.choices[0]?.message;\n    if (delta != null && snapshot?.role === 'assistant' && snapshot?.content) {\n      this._emit('content', delta, snapshot.content);\n    }\n  }, _ChatCompletionStream_endRequest = function _ChatCompletionStream_endRequest() {\n    if (this.ended) {\n      throw new error_1.OpenAIError(`stream has ended, this shouldn't happen`);\n    }\n    const snapshot = __classPrivateFieldGet(this, _ChatCompletionStream_currentChatCompletionSnapshot, \"f\");\n    if (!snapshot) {\n      throw new error_1.OpenAIError(`request ended without sending any chunks`);\n    }\n    __classPrivateFieldSet(this, _ChatCompletionStream_currentChatCompletionSnapshot, undefined, \"f\");\n    return finalizeChatCompletion(snapshot);\n  }, _ChatCompletionStream_accumulateChatCompletion = function _ChatCompletionStream_accumulateChatCompletion(chunk) {\n    let snapshot = __classPrivateFieldGet(this, _ChatCompletionStream_currentChatCompletionSnapshot, \"f\");\n    if (!snapshot) {\n      const {\n        choices,\n        ...rest\n      } = chunk;\n      __classPrivateFieldSet(this, _ChatCompletionStream_currentChatCompletionSnapshot, snapshot = {\n        ...rest,\n        choices: []\n      }, \"f\");\n    }\n    for (const {\n      delta,\n      finish_reason,\n      index\n    } of chunk.choices) {\n      let choice = snapshot.choices[index];\n      if (!choice) snapshot.choices[index] = choice = {\n        finish_reason,\n        index,\n        message: delta\n      };else {\n        if (finish_reason) choice.finish_reason = finish_reason;\n        const {\n          content,\n          function_call,\n          role\n        } = delta;\n        if (content) choice.message.content = (choice.message.content || '') + content;\n        if (role) choice.message.role = role;\n        if (function_call) {\n          if (!choice.message.function_call) choice.message.function_call = function_call;else {\n            if (function_call.arguments) choice.message.function_call.arguments = (choice.message.function_call.arguments || '') + function_call.arguments;\n            if (function_call.name) choice.message.function_call.name = function_call.name;\n          }\n        }\n      }\n    }\n    return snapshot;\n  }, Symbol.asyncIterator)]() {\n    const pushQueue = [];\n    const readQueue = [];\n    let done = false;\n    this.on('chunk', chunk => {\n      const reader = readQueue.shift();\n      if (reader) {\n        reader(chunk);\n      } else {\n        pushQueue.push(chunk);\n      }\n    });\n    this.on('end', () => {\n      done = true;\n      for (const reader of readQueue) {\n        reader(undefined);\n      }\n      readQueue.length = 0;\n    });\n    return {\n      next: async () => {\n        if (!pushQueue.length) {\n          if (done) {\n            return {\n              value: undefined,\n              done: true\n            };\n          }\n          return new Promise(resolve => readQueue.push(resolve)).then(chunk => chunk ? {\n            value: chunk,\n            done: false\n          } : {\n            value: undefined,\n            done: true\n          });\n        }\n        const chunk = pushQueue.shift();\n        return {\n          value: chunk,\n          done: false\n        };\n      }\n    };\n  }\n  toReadableStream() {\n    const stream = new streaming_1.Stream(this[Symbol.asyncIterator].bind(this), this.controller);\n    return stream.toReadableStream();\n  }\n}\nexports.ChatCompletionStream = ChatCompletionStream;\nfunction finalizeChatCompletion(snapshot) {\n  const {\n    id,\n    choices,\n    created,\n    model\n  } = snapshot;\n  return {\n    id,\n    choices: choices.map(({\n      message,\n      finish_reason,\n      index\n    }) => {\n      if (!finish_reason) throw new error_1.OpenAIError(`missing finish_reason for choice ${index}`);\n      const {\n        content = null,\n        function_call,\n        role\n      } = message;\n      if (!role) throw new error_1.OpenAIError(`missing role for choice ${index}`);\n      if (function_call) {\n        const {\n          arguments: args,\n          name\n        } = function_call;\n        if (args == null) throw new error_1.OpenAIError(`missing function_call.arguments for choice ${index}`);\n        if (!name) throw new error_1.OpenAIError(`missing function_call.name for choice ${index}`);\n        return {\n          message: {\n            content,\n            function_call: {\n              arguments: args,\n              name\n            },\n            role\n          },\n          finish_reason,\n          index\n        };\n      }\n      return {\n        message: {\n          content: content,\n          role\n        },\n        finish_reason,\n        index\n      };\n    }),\n    created,\n    model,\n    object: 'chat.completion'\n  };\n}","map":{"version":3,"names":["error_1","require","AbstractChatCompletionRunner_1","streaming_1","ChatCompletionStream","AbstractChatCompletionRunner","constructor","_ChatCompletionStream_currentChatCompletionSnapshot","set","currentChatCompletionSnapshot","__classPrivateFieldGet","fromReadableStream","stream","runner","_run","_fromReadableStream","createChatCompletion","completions","params","options","_runChatCompletion","_createChatCompletion","signal","aborted","controller","abort","addEventListener","_ChatCompletionStream_instances","_ChatCompletionStream_beginRequest","call","create","_connected","chunk","_ChatCompletionStream_addChunk","APIUserAbortError","_addChatCompletion","_ChatCompletionStream_endRequest","readableStream","Stream","chatId","id","WeakMap","WeakSet","ended","__classPrivateFieldSet","undefined","completion","_ChatCompletionStream_accumulateChatCompletion","_emit","delta","choices","content","snapshot","message","role","OpenAIError","finalizeChatCompletion","rest","finish_reason","index","choice","function_call","arguments","name","Symbol","asyncIterator","pushQueue","readQueue","done","on","reader","shift","push","length","next","value","Promise","resolve","then","toReadableStream","bind","exports","created","model","map","args","object"],"sources":["/Users/ranjithsreekaranuradhagopinath/Desktop/Projects/chatgpt_clone/clone/node_modules/openai/src/lib/ChatCompletionStream.ts"],"sourcesContent":["import * as Core from \"../core\";\nimport { OpenAIError, APIUserAbortError } from \"../error\";\nimport {\n  Completions,\n  type ChatCompletion,\n  type ChatCompletionChunk,\n  type ChatCompletionCreateParams,\n  ChatCompletionCreateParamsBase,\n} from \"../resources/chat/completions\";\nimport {\n  AbstractChatCompletionRunner,\n  type AbstractChatCompletionRunnerEvents,\n} from './AbstractChatCompletionRunner';\nimport { type ReadableStream } from \"../_shims/index\";\nimport { Stream } from \"../streaming\";\n\nexport interface ChatCompletionStreamEvents extends AbstractChatCompletionRunnerEvents {\n  content: (contentDelta: string, contentSnapshot: string) => void;\n  chunk: (chunk: ChatCompletionChunk, snapshot: ChatCompletionSnapshot) => void;\n}\n\nexport type ChatCompletionStreamParams = Omit<ChatCompletionCreateParamsBase, 'stream'> & {\n  stream?: true;\n};\n\nexport class ChatCompletionStream\n  extends AbstractChatCompletionRunner<ChatCompletionStreamEvents>\n  implements AsyncIterable<ChatCompletionChunk>\n{\n  #currentChatCompletionSnapshot: ChatCompletionSnapshot | undefined;\n\n  get currentChatCompletionSnapshot(): ChatCompletionSnapshot | undefined {\n    return this.#currentChatCompletionSnapshot;\n  }\n\n  /**\n   * Intended for use on the frontend, consuming a stream produced with\n   * `.toReadableStream()` on the backend.\n   *\n   * Note that messages sent to the model do not appear in `.on('message')`\n   * in this context.\n   */\n  static fromReadableStream(stream: ReadableStream): ChatCompletionStream {\n    const runner = new ChatCompletionStream();\n    runner._run(() => runner._fromReadableStream(stream));\n    return runner;\n  }\n\n  static createChatCompletion(\n    completions: Completions,\n    params: ChatCompletionStreamParams,\n    options?: Core.RequestOptions,\n  ): ChatCompletionStream {\n    const runner = new ChatCompletionStream();\n    runner._run(() => runner._runChatCompletion(completions, { ...params, stream: true }, options));\n    return runner;\n  }\n\n  #beginRequest() {\n    if (this.ended) return;\n    this.#currentChatCompletionSnapshot = undefined;\n  }\n  #addChunk(chunk: ChatCompletionChunk) {\n    if (this.ended) return;\n    const completion = this.#accumulateChatCompletion(chunk);\n    this._emit('chunk', chunk, completion);\n    const delta = chunk.choices[0]?.delta.content;\n    const snapshot = completion.choices[0]?.message;\n    if (delta != null && snapshot?.role === 'assistant' && snapshot?.content) {\n      this._emit('content', delta, snapshot.content);\n    }\n  }\n  #endRequest(): ChatCompletion {\n    if (this.ended) {\n      throw new OpenAIError(`stream has ended, this shouldn't happen`);\n    }\n    const snapshot = this.#currentChatCompletionSnapshot;\n    if (!snapshot) {\n      throw new OpenAIError(`request ended without sending any chunks`);\n    }\n    this.#currentChatCompletionSnapshot = undefined;\n    return finalizeChatCompletion(snapshot);\n  }\n\n  protected override async _createChatCompletion(\n    completions: Completions,\n    params: ChatCompletionCreateParams,\n    options?: Core.RequestOptions,\n  ): Promise<ChatCompletion> {\n    const signal = options?.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    this.#beginRequest();\n    const stream = await completions.create(\n      { ...params, stream: true },\n      { ...options, signal: this.controller.signal },\n    );\n    this._connected();\n    for await (const chunk of stream) {\n      this.#addChunk(chunk);\n    }\n    if (stream.controller.signal?.aborted) {\n      throw new APIUserAbortError();\n    }\n    return this._addChatCompletion(this.#endRequest());\n  }\n\n  protected async _fromReadableStream(\n    readableStream: ReadableStream,\n    options?: Core.RequestOptions,\n  ): Promise<ChatCompletion> {\n    const signal = options?.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    this.#beginRequest();\n    this._connected();\n    const stream = Stream.fromReadableStream<ChatCompletionChunk>(readableStream, this.controller);\n    let chatId;\n    for await (const chunk of stream) {\n      if (chatId && chatId !== chunk.id) {\n        // A new request has been made.\n        this._addChatCompletion(this.#endRequest());\n      }\n\n      this.#addChunk(chunk);\n      chatId = chunk.id;\n    }\n    if (stream.controller.signal?.aborted) {\n      throw new APIUserAbortError();\n    }\n    return this._addChatCompletion(this.#endRequest());\n  }\n\n  #accumulateChatCompletion(chunk: ChatCompletionChunk): ChatCompletionSnapshot {\n    let snapshot = this.#currentChatCompletionSnapshot;\n    if (!snapshot) {\n      const { choices, ...rest } = chunk;\n      this.#currentChatCompletionSnapshot = snapshot = {\n        ...rest,\n        choices: [],\n      };\n    }\n    for (const { delta, finish_reason, index } of chunk.choices) {\n      let choice = snapshot.choices[index];\n      if (!choice) snapshot.choices[index] = choice = { finish_reason, index, message: delta };\n      else {\n        if (finish_reason) choice.finish_reason = finish_reason;\n        const { content, function_call, role } = delta;\n        if (content) choice.message.content = (choice.message.content || '') + content;\n        if (role) choice.message.role = role;\n        if (function_call) {\n          if (!choice.message.function_call) choice.message.function_call = function_call;\n          else {\n            if (function_call.arguments)\n              choice.message.function_call.arguments =\n                (choice.message.function_call.arguments || '') + function_call.arguments;\n            if (function_call.name) choice.message.function_call.name = function_call.name;\n          }\n        }\n      }\n    }\n    return snapshot;\n  }\n\n  [Symbol.asyncIterator](): AsyncIterator<ChatCompletionChunk> {\n    const pushQueue: ChatCompletionChunk[] = [];\n    const readQueue: ((chunk: ChatCompletionChunk | undefined) => void)[] = [];\n    let done = false;\n\n    this.on('chunk', (chunk) => {\n      const reader = readQueue.shift();\n      if (reader) {\n        reader(chunk);\n      } else {\n        pushQueue.push(chunk);\n      }\n    });\n\n    this.on('end', () => {\n      done = true;\n      for (const reader of readQueue) {\n        reader(undefined);\n      }\n      readQueue.length = 0;\n    });\n\n    return {\n      next: async (): Promise<IteratorResult<ChatCompletionChunk>> => {\n        if (!pushQueue.length) {\n          if (done) {\n            return { value: undefined, done: true };\n          }\n          return new Promise<ChatCompletionChunk | undefined>((resolve) => readQueue.push(resolve)).then(\n            (chunk) => (chunk ? { value: chunk, done: false } : { value: undefined, done: true }),\n          );\n        }\n        const chunk = pushQueue.shift()!;\n        return { value: chunk, done: false };\n      },\n    };\n  }\n\n  toReadableStream(): ReadableStream {\n    const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);\n    return stream.toReadableStream();\n  }\n}\n\nfunction finalizeChatCompletion(snapshot: ChatCompletionSnapshot): ChatCompletion {\n  const { id, choices, created, model } = snapshot;\n  return {\n    id,\n    choices: choices.map(({ message, finish_reason, index }): ChatCompletion.Choice => {\n      if (!finish_reason) throw new OpenAIError(`missing finish_reason for choice ${index}`);\n      const { content = null, function_call, role } = message;\n      if (!role) throw new OpenAIError(`missing role for choice ${index}`);\n      if (function_call) {\n        const { arguments: args, name } = function_call;\n        if (args == null) throw new OpenAIError(`missing function_call.arguments for choice ${index}`);\n        if (!name) throw new OpenAIError(`missing function_call.name for choice ${index}`);\n        return { message: { content, function_call: { arguments: args, name }, role }, finish_reason, index };\n      }\n      return { message: { content: content, role }, finish_reason, index };\n    }),\n    created,\n    model,\n    object: 'chat.completion',\n  };\n}\n\n/**\n * Represents a streamed chunk of a chat completion response returned by model,\n * based on the provided input.\n */\nexport interface ChatCompletionSnapshot {\n  /**\n   * A unique identifier for the chat completion.\n   */\n  id: string;\n\n  /**\n   * A list of chat completion choices. Can be more than one if `n` is greater\n   * than 1.\n   */\n  choices: Array<ChatCompletionSnapshot.Choice>;\n\n  /**\n   * The Unix timestamp (in seconds) of when the chat completion was created.\n   */\n  created: number;\n\n  /**\n   * The model to generate the completion.\n   */\n  model: string;\n}\n\nexport namespace ChatCompletionSnapshot {\n  export interface Choice {\n    /**\n     * A chat completion delta generated by streamed model responses.\n     */\n    message: Choice.Message;\n\n    /**\n     * The reason the model stopped generating tokens. This will be `stop` if the model\n     * hit a natural stop point or a provided stop sequence, `length` if the maximum\n     * number of tokens specified in the request was reached, `content_filter` if\n     * content was omitted due to a flag from our content filters, or `function_call`\n     * if the model called a function.\n     */\n    finish_reason: 'stop' | 'length' | 'function_call' | 'content_filter' | null;\n\n    /**\n     * The index of the choice in the list of choices.\n     */\n    index: number;\n  }\n\n  export namespace Choice {\n    /**\n     * A chat completion delta generated by streamed model responses.\n     */\n    export interface Message {\n      /**\n       * The contents of the chunk message.\n       */\n      content?: string | null;\n\n      /**\n       * The name and arguments of a function that should be called, as generated by the\n       * model.\n       */\n      function_call?: Message.FunctionCall;\n\n      /**\n       * The role of the author of this message.\n       */\n      role?: 'system' | 'user' | 'assistant' | 'function';\n    }\n\n    export namespace Message {\n      /**\n       * The name and arguments of a function that should be called, as generated by the\n       * model.\n       */\n      export interface FunctionCall {\n        /**\n         * The arguments to call the function with, as generated by the model in JSON\n         * format. Note that the model does not always generate valid JSON, and may\n         * hallucinate parameters not defined by your function schema. Validate the\n         * arguments in your code before calling your function.\n         */\n        arguments?: string;\n\n        /**\n         * The name of the function to call.\n         */\n        name?: string;\n      }\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}